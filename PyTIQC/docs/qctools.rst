============
core.qctools
============

This module contains the core of the simulation, which is in the function ``simulationCore``.

simulationCore
--------------

.. autofunction:: PyTIQC.core.qctools.simulationCore

The general logic in this function is as follows:

#. construct an empty time vector *T* and state vector *Y*
#. initialize indices and pointer variables to keep track of current pulse, state, time
#. initialize the Hamiltonian and Noise objects (see :doc:`qmtools`) and fetch the noise dictionary
#. initialize the pulses to have time-dependent methods
#. Start the time evolution by looping over each pulse.
#. save *T* and *Y* into a database object
#. remove time-dependent methods from pulses, and return database object.

Details of the time evolution: there are three if-branches for each pulse.

* if pulse.use_ideal = True, compute the state at the end of the pulse using the given ideal unitary operator (``pulse.U``), save it into *Y* and advance to the next pulse. Note that in this case, all states in the middle of the pulse are not computed/stored.
* if pulse.dotimedepPulse = False, use the pulse parameter to retrieve the Hamiltonian and compute states using matrix exponentiation. 
* if pulse.dotimedepPulse = True, use the ODE solver to compute states. The timesteps used in the ODE (``params.ODEtimestep``) can be different than the one used for the matrix exponentiation (``params.stepsize``). In particular the ODE solver requires a minimal timestep to converge and this depends on the detuning. Thus the state and time vector generated by the ODE solver need to be stitched back into the main *T* and *Y* vectors at the end of the pulse.

Matrix exponentiation in ``simulationCore`` is done using the ``expm2`` function from Scipy, which computes the matrix exponential using eigenvalue decomposition. Alternatively there is also the ``expm`` function from ``scipy.linalg.expm``. This is the same operation as Matlab's expm function and the same one in LAPACK, and uses the Pade approximation of order q=7. I chose to use ``expm2`` because it seems a little faster.

``simulationCore`` is called by:

simulateevolution
-----------------

.. autofunction:: PyTIQC.core.qctools.simulateevolution

This function should be called by top-level scripts. It takes care of the specific case where the input state should be a density matrix, in which case it finds the eigenstates and runs the simulation for each eigenstate. Otherwise it's a wrapper for:

.. autofunction:: PyTIQC.core.qctools.simulateevolutionOnce

This function initializes the arrays of random variables that control the behavior of decoherence. It simply calls the appropriate generating functions in the decoherence object. If parallel processing is turned on (with ``params.doPP``), it initializes the parallel processing ``job_server``, and starts each job with distinct decoherence objects.

other helper functions
----------------------

.. autofunction:: PyTIQC.core.qctools.loadRun

.. autofunction:: PyTIQC.core.qctools.saveRun
